<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains [`Trace`]s consisting of several [`Step`]s, of which each has either an [`OutputAction`] or [`InputAction`]. This is a declarative way of modeling communication between [`Agent`]s. The [`TraceContext`] holds data, also known as [`VariableData`], which is created by [`Agent`]s during the concrete execution of the Trace. It also holds the [`Agent`]s with the references to concrete PUT."><meta name="keywords" content="rust, rustlang, rust-lang, trace"><title>tlspuffin::trace - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../tlspuffin/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Module trace</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class="location"><a href="../index.html">tlspuffin</a></p><div id="sidebar-vars" data-name="trace" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">tlspuffin</a>::<wbr><a class="mod" href="">trace</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/tlspuffin/trace.rs.html#1-663" title="goto source code">[src]</a></span></h1><div class="docblock"><p>This module contains <a href="struct.Trace.html" title="Trace"><code>Trace</code></a>s consisting of several <a href="struct.Step.html" title="Step"><code>Step</code></a>s, of which each has either an
<a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> or <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a>. This is a declarative way of modeling communication between
<a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s. The <a href="struct.TraceContext.html" title="TraceContext"><code>TraceContext</code></a> holds data, also known as <a href="../variable_data/trait.VariableData.html" title="VariableData"><code>VariableData</code></a>, which is created by
<a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s during the concrete execution of the Trace. It also holds the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s with
the references to concrete PUT.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">tlspuffin::agent</span>::{<span class="ident">AgentName</span>, <span class="ident">AgentDescriptor</span>, <span class="ident">TLSVersion</span>::<span class="kw-2">*</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::trace</span>::{<span class="ident">Step</span>, <span class="ident">TraceContext</span>, <span class="ident">Trace</span>, <span class="ident">Action</span>, <span class="ident">InputAction</span>, <span class="ident">OutputAction</span>, <span class="ident">Query</span>, <span class="ident">TlsMessageType</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::term</span>::{<span class="ident">Term</span>, <span class="ident">signature::Signature</span>};
<span class="kw">use</span> <span class="ident">tlspuffin::tls::fn_impl::fn_client_hello</span>;
<span class="kw">use</span> <span class="ident">rustls</span>::{<span class="ident">ProtocolVersion</span>, <span class="ident">CipherSuite</span>};
<span class="kw">use</span> <span class="ident">rustls::msgs::handshake</span>::{<span class="ident">SessionID</span>, <span class="ident">Random</span>, <span class="ident">ClientExtension</span>};
<span class="kw">use</span> <span class="ident">rustls::msgs::enums</span>::{<span class="ident">Compression</span>, <span class="ident">HandshakeType</span>};

<span class="kw">let</span> <span class="ident">client</span>: <span class="ident">AgentName</span> <span class="op">=</span> <span class="ident">AgentName::first</span>();
<span class="kw">let</span> <span class="ident">server</span>: <span class="ident">AgentName</span> <span class="op">=</span> <span class="ident">client</span>.<span class="ident">next</span>();

<span class="kw">let</span> <span class="ident">query</span> <span class="op">=</span> <span class="ident">Query</span> {
    <span class="ident">agent_name</span>: <span class="ident">client</span>,
    <span class="ident">tls_message_type</span>: <span class="prelude-val">Some</span>(<span class="ident">TlsMessageType::Handshake</span>(<span class="prelude-val">Some</span>(<span class="ident">HandshakeType::ClientHello</span>))),
    <span class="ident">counter</span>: <span class="number">0</span>
};
<span class="kw">let</span> <span class="ident">trace</span> <span class="op">=</span> <span class="ident">Trace</span> {
    <span class="ident">prior_traces</span>: <span class="macro">vec!</span>[],
    <span class="ident">descriptors</span>: <span class="macro">vec!</span>[
        <span class="ident">AgentDescriptor::new_client</span>(<span class="ident">client</span>, <span class="ident">V1_3</span>),
        <span class="ident">AgentDescriptor::new_server</span>(<span class="ident">server</span>, <span class="ident">V1_3</span>)
    ],
    <span class="ident">steps</span>: <span class="macro">vec!</span>[
            <span class="ident">Step</span> { <span class="ident">agent</span>: <span class="ident">client</span>, <span class="ident">action</span>: <span class="ident">Action::Output</span>(<span class="ident">OutputAction</span> { }) },
            <span class="comment">// Client: Hello Client -&gt; Server</span>
            <span class="ident">Step</span> {
                <span class="ident">agent</span>: <span class="ident">server</span>,
                <span class="ident">action</span>: <span class="ident">Action::Input</span>(<span class="ident">InputAction</span> {
                    <span class="ident">recipe</span>: <span class="ident">Term::Application</span>(
                        <span class="ident">Signature::new_function</span>(<span class="kw-2">&amp;</span><span class="ident">fn_client_hello</span>),
                        <span class="macro">vec!</span>[
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">ProtocolVersion</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Random</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">SessionID</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">CipherSuite</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Compression</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                            <span class="ident">Term::Variable</span>(<span class="ident">Signature::new_var</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ClientExtension</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">query</span>)),
                        ],
                    ),
                }),
            },
    <span class="comment">// further steps here</span>
    ]
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ctx</span> <span class="op">=</span> <span class="ident">TraceContext::new</span>();
<span class="ident">trace</span>.<span class="ident">execute</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ctx</span>).<span class="ident">unwrap</span>();</pre></div>
<h3 id="serializability-of-traces" class="section-header"><a href="#serializability-of-traces">Serializability of Traces</a></h3>
<p>Each trace is serializable to JSON or even binary data. This helps at reproducing discovered
security vulnerabilities during fuzzing. If a trace triggers a security vulnerability we can
store it on disk and replay it when investigating the case.
As traces depend on concrete implementations as discussed in the next section we need to link
serialized data like strings or numerical IDs to functions implemented in Rust.</p>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.AgentClaimer.html" title="tlspuffin::trace::AgentClaimer struct">AgentClaimer</a></td><td class="docblock-short"><p>Claimer which gets claims from a VecClaimer but filters by <a href="../agent/struct.AgentName.html" title="AgentName"><code>AgentName</code></a></p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.InputAction.html" title="tlspuffin::trace::InputAction struct">InputAction</a></td><td class="docblock-short"><p>The <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a> evaluates the recipe term and injects the newly produced message
into the <em>inbound channel</em> of the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a> referenced through the corresponding <a href="struct.Step.html" title="Step"><code>Step</code></a>s
by calling <code>add_to_inbound(...)</code> and then drives the state machine forward.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Knowledge.html" title="tlspuffin::trace::Knowledge struct">Knowledge</a></td><td class="docblock-short"><p><a href="struct.Knowledge.html" title="Knowledge">Knowledge</a> describes an atomic piece of knowledge inferred
by the <a href="../variable_data/fn.extract_knowledge.html" title="crate::variable_data::extract_knowledge"><code>crate::variable_data::extract_knowledge</code></a> function
<a href="struct.Knowledge.html" title="Knowledge">Knowledge</a> is made of the data, the agent that produced the output, the TLS message type and the internal type.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.OutputAction.html" title="tlspuffin::trace::OutputAction struct">OutputAction</a></td><td class="docblock-short"><p>The <a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> first forwards the state machine and then extracts knowledge from the
TLS messages produced by the underlying stream by calling  <code>take_message_from_outbound(...)</code>.
An output action is automatically called after each input step.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Query.html" title="tlspuffin::trace::Query struct">Query</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.Step.html" title="tlspuffin::trace::Step struct">Step</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.Trace.html" title="tlspuffin::trace::Trace struct">Trace</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.TraceContext.html" title="tlspuffin::trace::TraceContext struct">TraceContext</a></td><td class="docblock-short"><p>The <a href="struct.TraceContext.html" title="TraceContext"><code>TraceContext</code></a> contains a list of <a href="../variable_data/trait.VariableData.html" title="VariableData"><code>VariableData</code></a>, which is known as the knowledge
of the attacker. <a href="../variable_data/trait.VariableData.html" title="VariableData"><code>VariableData</code></a> can contain data of various types like for example
client and server extensions, cipher suits or session ID It also holds the concrete
references to the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a>s and the underlying streams, which contain the messages
which have need exchanged and are not yet processed by an output step.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.VecClaimer.html" title="tlspuffin::trace::VecClaimer struct">VecClaimer</a></td><td class="docblock-short"></td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.Action.html" title="tlspuffin::trace::Action enum">Action</a></td><td class="docblock-short"><p>There are two action types <a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> and <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a> differ.
Both actions drive the internal state machine of an <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a> forward by calling <code>next_state()</code>.
The <a href="struct.OutputAction.html" title="OutputAction"><code>OutputAction</code></a> first forwards the state machine and then extracts knowledge from the
TLS messages produced by the underlying stream by calling  <code>take_message_from_outbound(...)</code>.
The <a href="struct.InputAction.html" title="InputAction"><code>InputAction</code></a> evaluates the recipe term and injects the newly produced message
into the <em>inbound channel</em> of the <a href="../agent/struct.Agent.html" title="Agent"><code>Agent</code></a> referenced through the corresponding <a href="struct.Step.html" title="Step"><code>Step</code></a>s
by calling <code>add_to_inbound(...)</code> and then drives the state machine forward.
Therefore, the difference is that one step <em>increases</em> the knowledge of the attacker,
whereas the other action <em>uses</em> the available knowledge.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.TlsMessageType.html" title="tlspuffin::trace::TlsMessageType enum">TlsMessageType</a></td><td class="docblock-short"><p>[MessageType] contains TLS-related typing information, this is to be distinguished from the *.typ fields
It uses [rustls::msgs::enums::{ContentType,HandshakeType}].</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.QueryMatcher.html" title="tlspuffin::trace::QueryMatcher trait">QueryMatcher</a></td><td class="docblock-short"></td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="tlspuffin" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script></body></html>